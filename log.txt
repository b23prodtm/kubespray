atal: [raspberrypib]: FAILED! = true, cmd: [timeout, -k, 600s, 600s, /usr/local/bin/kubeadm, init, --config=/etc/kubernetes/kubeadm-config.yaml, --ignore-preflight-errors=all], delta: 0:05:25.815576, end: 2019-04-10 08:40:16.558000, failed_when_result: true, msg: non-zero return code, rc: 1, start: 2019-04-10 08:34:50.742424, stderr: error execution phase wait-control-plane: couldn't initialize a Kubernetes cluster, stderr_lines: [error execution phase wait-control-plane: couldn't initialize a Kubernetes cluster], stdout: [init] Using Kubernetes version: v1.13.5
[preflight] Running pre-flight checks
[preflight] Pulling images required for setting up a Kubernetes cluster
[preflight] This might take a minute or two, depending on the speed of your internet connection
[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'
[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"
[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"
[kubelet-start] Activating the kubelet service
[certs] Using certificateDir folder "/etc/kubernetes/ssl"
[certs] Generating "ca" certificate and key
[certs] Generating "apiserver" certificate and key
[certs] apiserver serving cert is signed for DNS names [raspberrypib kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local localhost raspberrypib] and IPs [10.233.0.1 192.168.0.36 192.168.0.36 10.233.0.1 127.0.0.1 192.168.0.36]
[certs] Generating "apiserver-kubelet-client" certificate and key
[certs] External etcd mode: Skipping etcd/ca certificate authority generation
[certs] External etcd mode: Skipping apiserver-etcd-client certificate authority generation
[certs] External etcd mode: Skipping etcd/peer certificate authority generation
[certs] External etcd mode: Skipping etcd/healthcheck-client certificate authority generation
[certs] External etcd mode: Skipping etcd/server certificate authority generation
[certs] Generating "front-proxy-ca" certificate and key
[certs] Generating "front-proxy-client" certificate and key
[certs] Generating "sa" key and public key
[kubeconfig] Using kubeconfig folder "/etc/kubernetes"
[kubeconfig] Writing "admin.conf" kubeconfig file
[kubeconfig] Writing "kubelet.conf" kubeconfig file
[kubeconfig] Writing "controller-manager.conf" kubeconfig file
[kubeconfig] Writing "scheduler.conf" kubeconfig file
[control-plane] Using manifest folder "/etc/kubernetes/manifests"
[control-plane] Creating static Pod manifest for "kube-apiserver"
[controlplane] Adding extra host path mount "usr-share-ca-certificates" to "kube-apiserver"
[control-plane] Creating static Pod manifest for "kube-controller-manager"
[controlplane] Adding extra host path mount "usr-share-ca-certificates" to "kube-apiserver"
[control-plane] Creating static Pod manifest for "kube-scheduler"
[controlplane] Adding extra host path mount "usr-share-ca-certificates" to "kube-apiserver"
[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 5m0s
[kubelet-check] Initial timeout of 40s passed.

Unfortunately, an error has occurred:
	timed out waiting for the condition

This error is likely caused by:
	- The kubelet is not running
	- The kubelet is unhealthy due to a misconfiguration of the node in some way (required cgroups disabled)

If you are on a systemd-powered system, you can try to troubleshoot the error with the following commands:
	- 'systemctl status kubelet'
	- 'journalctl -xeu kubelet'

Additionally, a control plane component may have crashed or exited when started by the container runtime.
To troubleshoot, list all containers using your preferred container runtimes CLI, e.g. docker.
Here is one example how you may list all Kubernetes containers running in docker:
	- 'docker ps -a | grep kube | grep -v pause'
	Once you have found the failing container, you can inspect its logs with:
	- 'docker logs CONTAINERID', stdout_lines: [[init] Using Kubernetes version: v1.13.5, [preflight] Running pre-flight checks, [preflight] Pulling images required for setting up a Kubernetes cluster, [preflight] This might take a minute or two, depending on the speed of your internet connection, [preflight] You can also perform this action in beforehand using 'kubeadm config images pull', [kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env", [kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml", [kubelet-start] Activating the kubelet service, [certs] Using certificateDir folder "/etc/kubernetes/ssl", [certs] Generating "ca" certificate and key, [certs] Generating "apiserver" certificate and key, [certs] apiserver serving cert is signed for DNS names [raspberrypib kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local localhost raspberrypib] and IPs [10.233.0.1 192.168.0.36 192.168.0.36 10.233.0.1 127.0.0.1 192.168.0.36], [certs] Generating "apiserver-kubelet-client" certificate and key, [certs] External etcd mode: Skipping etcd/ca certificate authority generation, [certs] External etcd mode: Skipping apiserver-etcd-client certificate authority generation, [certs] External etcd mode: Skipping etcd/peer certificate authority generation, [certs] External etcd mode: Skipping etcd/healthcheck-client certificate authority generation, [certs] External etcd mode: Skipping etcd/server certificate authority generation, [certs] Generating "front-proxy-ca" certificate and key, [certs] Generating "front-proxy-client" certificate and key, [certs] Generating "sa" key and public key, [kubeconfig] Using kubeconfig folder "/etc/kubernetes", [kubeconfig] Writing "admin.conf" kubeconfig file, [kubeconfig] Writing "kubelet.conf" kubeconfig file, [kubeconfig] Writing "controller-manager.conf" kubeconfig file, [kubeconfig] Writing "scheduler.conf" kubeconfig file, [control-plane] Using manifest folder "/etc/kubernetes/manifests", [control-plane] Creating static Pod manifest for "kube-apiserver", [controlplane] Adding extra host path mount "usr-share-ca-certificates" to "kube-apiserver", [control-plane] Creating static Pod manifest for "kube-controller-manager", [controlplane] Adding extra host path mount "usr-share-ca-certificates" to "kube-apiserver", [control-plane] Creating static Pod manifest for "kube-scheduler", [controlplane] Adding extra host path mount "usr-share-ca-certificates" to "kube-apiserver", [wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests". This can take up to 5m0s, [kubelet-check] Initial timeout of 40s passed., , Unfortunately, an error has occurred:, 	timed out waiting for the condition, , This error is likely caused by:, 	- The kubelet is not running, 	- The kubelet is unhealthy due to a misconfiguration of the node in some way (required cgroups disabled), , If you are on a systemd-powered system, you can try to troubleshoot the error with the following commands:, 	- 'systemctl status kubelet', 	- 'journalctl -xeu kubelet', , Additionally, a control plane component may have crashed or exited when started by the container runtime., To troubleshoot, list all containers using your preferred container runtimes CLI, e.g. docker., Here is one example how you may list all Kubernetes containers running in docker:, 	- 'docker ps -a | grep kube | grep -v pause', 	Once you have found the failing container, you can inspect its logs with:, \t- 'docker logs CONTAINERID']}
